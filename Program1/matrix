#!/bin/bash

# CS344 Program 1
# David LaMartina
# lamartid@oregonstate.edu
# Due April 22, 2019

# Overview:
#   Basic matrix operations
# Specifications
#   dims: print dimensions as ROWS COLUMNS
#   transpose: reflect elements along main diagonal (MxN becomes NxM)
#   mean: accept MxN matrix, return 1xN row vector
#   add: two MxN matrices, add together element-wise
#   multiply: MxN matrix and NxP matrix mult'd to produce MxP matrix (not commutative)
#
#   Check number and format of arguments (is file readable)
#       ***NOT required to test whether input is valid***
#   Valid matrix:
#       tab-delimited table w/ at least one element
#       each element signed integer
#       every entry defined
#       rectangular
#   Invalid:
#       empty
#       file entry on row followed by tab
#       matrix w/ empty lines
#       matrix w/ any elements left blank / non-integer
#   Output
#       valid input: only output to stoud -- return value 0
#       invalid input: only output to stderr -- return anything but 0 w/ some error msg
#       All values and results are integers
#   Temporary Files - recommended over arrays
#       put in current working directory
#       use ProcID as part of name ($$)
#       Remove all temp files when done
#       Use trap command to catch interrupt, hangup, terminate signals
#   Rounding
#       For average, round to nearest integer, away from 0 (up positive, down negative)
#       (a + (b/2)*( (a>0)*2-1 )) / b
#   Hints
#       Write each part as separate function and call with argument reference
#           $1 "${@:2}" would expand to multiply m1 m2 for 'matrix multiply m1 m2'
#           call at bottom of script
#       Use read command extensively to read from file
#           reads ONE line at a time from stdin buffer and stores line in variable REPLY
#           usually used in while loop, file directed to stdin of while loop
#       expr command and shell can conflict over special characters --> need \
#       

################################################################################
# argsReadable():
#   Verifies readability of arguments
# Input:
#   Series of argumentes of indefinite length
# Output:
#   If all args are readable, exit 0
#   If any arg is unreadable, exit 1 with error message
################################################################################
function argsReadable(){
    for arg in $@; do
        if ! [[ -r $arg ]]; then
            echo "Check your arguments. $arg is not readable"
            exit 1
        fi
    done
    exit 0
}
################################################################################
# argsNum(): 
#   Verifies a correct number of arguments
# Input:
#   First arg: correct number of arguments
#   Subsequent args: arguments passed in to be counted
# Output:
#   Exit 0 if number of arguments from 2 upward matches the first argument
#   Exit 1 with error message if discrepancy
################################################################################
function argsNum(){
    numArgs=0
    for arg in ${@:2}; do
        numArgs=$(($numArgs + 1))
    done
    if [ $numArgs -eq $1 ]; then
        exit 0
    else
        echo "You have entered an incorrect number of arguments"
        exit 1
    fi
}

################################################################################
# divNearest():
#   Divides arg 1 by arg 2 and returns rounded result
# Input:
#   2 integer arguments, 1st to be divided by second
# Output:
#   Rounded result of division. Positive results round up at 0.5, negative down.
################################################################################
function divNearest(){
    echo $(( ($1 + ($2 / 2) * ( ($1 > 0) * 2 - 1 )) / $2))
}

################################################################################
# average():
#   Finds average of indefinite number of integer arguments
# Input:
#   Indefinite number of integer arguments
# Output:
#   Rounded average - rounding performed by divNearest()
################################################################################
function average(){
    sum=0
    numArgs=0
    for num in "$@"; do
        sum=$(($sum + num))
        numArgs=$(($numArgs + 1))
    done
    echo $(divNearest $sum $numArgs)
}

################################################################################
# dims():
#   Outputs the dimensions of a matrix in 'ROWS COLUMNS' format.
# Input:
#   One rectangular matrix of integers
# Output:
#   Echos dimensions if valid.
#   Exits 1 with error message args > 1 or input is unreadable
################################################################################
function dims(){
    if ! (argsNum 1 ${@:1} && argsReadable ${@:1}); then
        exit 1
    else
        rows=0; cols=0;
        while read line; do
            rows=$(($rows + 1))
        done < $1
        for item in $(cat $1 | head -n 1); do
            cols=$(($cols + 1))
        done
        echo "$rows $cols"
        exit 0
    fi
}
################################################################################
# transpose():
#   'Reflects' elements of a matrix along its main (top-left to bottom-right)
# Input:
#   One rectangular matrix of integers
# Output:
#   Echos reflected matrix if valid.
#   Exits 1 with ereror message if args > 1 or input is unreadable
################################################################################
function transpose(){
    if ! (argsNum 1 ${@:1} && argsReadable ${@:1}); then
        exit 1
    else
        # Iterate through fields, using index to grab column. Transpose one
        # column at a time and output with paste single-line option to retain
        # appropriate tabs and new lines.
        # Solution using paste courtesy of
        # https://www.thelinuxrain.com/articles/transposing-rows-and-columns-3-methods
        idx=0
        for item in $(cat $1 | head -n 1); do
            idx=$((idx + 1))
            cut -f $idx $1 | paste -s
        done
    fi
}

################################################################################
# mean():
#   Given MxN matrix, outputs a 1xN vector, each element of which is the mean
#   of its associated column in the original matrix
# Input:
#   One rectangular matrix of integers
# Output:
#   1xN (1 x number of columns) vector representing means of original columns
################################################################################
function mean(){
    echo $(average 4 5 6 7 8 9 10)
}


################################################################################
# add():
#   Outputs 
################################################################################


function add(){
    if [[ "$#" -eq "1" && -r "$1" ]]
    then
        stuff
    else
        echo "Check your arguments."
        exit 1
    fi
}


datafilepath="datafile$$"
if [ "$#" = "1" ]
then
    cat > "$datafilepath"
    $1 $datafilepath
elif [ "$#" = "2" ]
then
    datafilepath=$2
    $1 $datafilepath
else
    $1 "${@:2}"
fi















